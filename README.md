# Cryptology Exam | Гринько Назар ІПС-31
Дата іспиту: 29.05.2023

## Варіант 3: Algorithm RSA & Diffie-Hellman protocol


---
## 1. RSA Algorithm:
**RSA (Advanced Encryption Standard)** - це асиметричний алгоритм криптографії. Асиметричний насправді означає, що він працює з двома різними ключами, тобто з відкритим і закритим ключами. Як випливає з назви, відкритий ключ надається всім, а закритий ключ зберігається в таємниці. RSA заснована на тому, що велике ціле число важко розкласти на множники. Відкритий ключ складається з двох чисел, де одне число є добутком двох великих простих чисел. І приватний ключ також є похідним від тих же двох простих чисел. Отже, якщо хтось може розкласти на множники велике число, приватний ключ буде скомпрометований. Тому стійкість шифрування повністю залежить від розміру ключа. Цей алгоритм реалізовано у наступних функціях: **rsa_encrypt(), rsa_decrypt(), generate_keys()**.

### Steps:
**Використання:**
1. Викличте функцію generate_keys(bit_length) для генерації відкритого та закритого ключів. Вкажіть бажану довжину бітів для ключів.
2. Запропонуйте користувачеві ввести текст, який потрібно зашифрувати.
3. Викликати функцію rsa_encrypt(public_key, plain_text) зі згенерованим відкритим ключем і відкритим текстом для шифрування.
4. Щоб розшифрувати зашифрований текст, викличте функцію rsa_decrypt(private_key, encrypted_text) зі згенерованим приватним ключем і зашифрованим текстом.
5. Виведіть ключі, зашифрований та розшифрований текст на консоль.


**generate_keys(bit_length)**
Генерує відкритий і закритий ключі, необхідні для алгоритму RSA.

* bit_length: Бажана довжина ключа в бітах.
  Повертає кортеж (public_key, private_key), що містить згенеровані відкритий (e, n) та закритий (d, n) ключі.

Функція **generate_keys(bit_length) виконує наступні дії:**

1. Викличте функцію generate_keys(bit_length), щоб згенерувати відкритий і закритий ключі. Вкажіть бажану довжину бітів для ключів.
2. Запропонуйте користувачеві ввести відкритий текст для шифрування.
3. Викликати функцію rsa_encrypt(public_key, plain_text) зі згенерованим відкритим ключем та відкритим текстом для його шифрування.
4. Щоб розшифрувати зашифрований текст, викличте функцію rsa_decrypt(private_key, encrypted_text) зі згенерованим приватним ключем і зашифрованим текстом.
5. Виведіть ключі, зашифрований і розшифрований текст на консоль.

### Helper Functions
**rsa_encrypt(public_key, plain_text)**
Шифрує вхідний відкритий текст за допомогою наданого відкритого ключа.

* public_key: Згенерований відкритий ключ (e, n).
* plain_text: Текст для шифрування.
  Повертає зашифрований текст з використанням відкритого ключа (e, n).

**rsa_decrypt(private_key, encrypted_text)**
Розшифровує вхідний зашифрований текст за допомогою наданого приватного ключа.

* private_key: Згенерований приватний ключ (d, n).
* encrypted_text: Текст, який потрібно розшифрувати.
  Повертає розшифрований текст з використанням закритого ключа (d, n).


---
## 2. Diffie-Hellman protocol:
**Diffie-Hellman protocol** - це протокол обміну ключами, який дозволяє двом сторонам встановити спільний секретний ключ по незахищеному каналу. Цей протокол реалізовано у наступних функціях: **diffie_hellman(), calc_public_values(), cal_secret_keys()**. Він базується на алгебраїчній структурі еліптичних кривих над скінченними полями. ECC вимагає меншого ключа у порівнянні з іншими криптографіями для забезпечення еквівалентної безпеки (256-бітний ключ ECC має еквівалентну безпеку, що досягається 3072-бітною криптографією RSA).

### Steps:
**Функція diffie_hellman() виконує наступні дії:**

1. Введіть публічні числа: Функція пропонує користувачам ввести два публічні числа, P і G. Ці числа повинні бути простими й ділитися між двома сторонами.
2. Введіть приватні ключі: Функція попросить двох користувачів ввести свої приватні ключі, x1 і x2. Закриті ключі повинні бути натуральними числами, меншими за відповідні відкриті числа.
3. Обчислити відкриті значення: Функція викликає функцію calc_public_values() для обчислення відкритих значень y1 та y2 за наданими формулами.
4. Обчислити секретні ключі: Функція викликає функцію cal_secret_keys() для обчислення секретних ключів secret_1 та secret_2 за наданими формулами.
5. Повернути секретні ключі: Функція повертає список, що містить секретні ключі обох користувачів.

### Helper Functions
**calc_public_values(g, p, x1, x2)**
Обчислює публічні значення для Користувача 1 та Користувача 2 за формулою: **user_1_pv = (g^x_1) mod (p)**, **(g^x_2) mod (p)**

* g: Відкритий ключ G.
* p: Відкритий ключ P.
* x1: приватний ключ користувача 1.
* x2: закритий ключ користувача 2.
Повертає відкриті значення Користувача 1 та Користувача 2.

**cal_secret_keys(p, x1, x2, y1, y2)**
Обчислює секретні ключі Користувача 1 та Користувача 2 за формулою: **user_1_sk = (y_2^x_1) mod (p)**, **(y_1^x_2) mod (p)**

* p: Відкритий ключ P.
* x1: закритий ключ користувача 1.
* x2: Закритий ключ користувача 2.
* y1: Відкрите значення Користувача 1.
* y2: Відкритий ключ користувача 2.
Повертає секретні ключі Користувача 1 та Користувача 2.